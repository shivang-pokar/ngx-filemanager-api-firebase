{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","__read","o","m","r","i","ar","error","__spread","arguments","concat","cors","require","OptionRequestsAreOk","req","res","method","console","log","status","send","PostRequestsOnly","msg","warn","HasBodyProp","bodyFieldName","HasQueryParam","paramName","query","GetTokenFromRequest","isInHeader","headers","startsWith","hasCookie","idToken","split","Error","__session","DecodeJWT","_a","bearer","jwt.decode","json","message","permsFactory","blankPermissionsObj","others","readers","writers","blankUserClaim","groups","SetMetaPropertyString","file","key","newValueString","metaObj","metadata","setMetadata","_b","fileExists","exists","e_1","filePath","name","error_1","GetMetaPropertyString","getMetadata","_c","meta","metaData","error_3","VError","error_2","permHelper","GetMetaPropertyObj","JSON","parse","error_4","SetMetaPropertyObj","newValue","stringify","TryCheckFileAccess","filePermissions","claims","toCheck","anyoneCanDo","othersPermissions","CanRead","CanWrite","CanOthersDo","userIsSudo","userAndGroups","user_id","IsPartOfArray","arr","usersGroups","userGroupSet","Set","find","entity","has","permsQueries","RetrieveFilePermissions","fromStorage","blank","Object","assign","RetrieveCustomClaims","token","TryCheckHasAnyPermissions","CheckCanEditPermissions","currentFilePermissions","newPermissions","canEditPermissions","canEditPermissionsAfter","perms","factory","commands","UpdateFilePermissions","queries","HasPrefixSlash","inputPath","HasTrailingSlash","endsWith","EnsureTrailingSlash","EnsureNoPrefixSlash","slice","EnsurePrefixSlash","EnsureNoTrailingSlash","EnsureGoogleStoragePathDir","folderPath","GetRelativePath","currentDirectoryPath","absObjectPath","IsObjNameDir","storageObjectName","GetFileNameWithExtension","paths","EnsureAbsolutePathFile","EnsureAbsolutePathDir","EnsureGoogleStoragePathFile","IsCurrentPath","IsCurrentPathFile","IsObjNameFile","GetSubDirectory","shift","GetParentDir","parsed","path.dirname","GetFileNameWithoutExtension","segments","join","GetPathUpToLastBracket","slashes","dirPath","fileName","bracketSegments","fileNameWith","includes","path.join","dotSegments","Add2ToPath","extension","Add2ToPathDir","translateRawStorage","storageObject","filePathParsed","ref","path.basename","fullPath","isDir","translateStorageToResFile","resFile","type","isPhantomFolder","permissions","acl","get","aclObj","rightsFirebase","metaResp","customMeta","size","date","updated","StreamToPromise","stream","stringRes","on","buffer","part","read","toString","err","errmsg","ResultsObjFromArray","moveResults","reduce","acc","cur","success","MakeOptionsListRoot","delimiter","includeTrailingDelimiter","autoPaginate","MakeOptionsList","inputDirectoryPath","directory","GetFilesAndPrefixes","bucket","options","getFiles","files","nextQuery","apiResponse","prefixes","GetListFromStorage","googleStorageDirPath","allObjects","map","allObjectsPathsSet_1","phantomPrefixes","filter","prefix","newPhantomFolders","phantomPath","pathParsed","combinedList","error_6","storage","GetListWithoutPermissions","all","error_7","GetAllChildrenWithPrefix","fileOrDirectoryPath","pathNoPrefix","TryRenameFile","oldPrefix","newPrefix","originalFilePath","relativePath","newPath","newFilePath","move","TryCopyFile","copy","TryCheckWritePermission","newDirPath","parentPath","parentDir","parentPermissions","RemoveFileWithChildren","itemPath","allChildren","delete","tryDeleteFile","successArray","moment","GetUrl","in5mins","add","toDate","config","expires","action","getSignedUrl","signedResult","CreateFolderWithoutPermissions","newDirectoryPath","directoryPath","save","blankPerms","GetNextFreeFoldername","targetChildDir","parentDirectory","childrenMatching","childrenMatchingPaths","targetFolderPath","folderExists","some","path","nextPath","SetPermissionToObj","permissionsObj","role","TryChangeSingleFilePermissions","SaveBufferToPath","mimetype","fileOptions","contentType","GetNextFreeFilename","inputFile","dirNameNoSuffix","matchingNames","sort","lastMatch","TryChangeSingleFilePermissionsObject","GetList","isAdmin","resFiles","RenameFile","inputSrc","inputDest","parsedSrc_1","parsedDest_1","fileItem","MoveFiles","items","newFolderPrefix_1","newFolderPrefix","oldFolderPrefix_1","moveWithChildren","moveResultsArrArr","CopyFiles","copyWithChildren","copyResultsArrArr","copyResultsArr","fail","statusCode","RemoveFiles","googleStorageItemPaths","p","allSuccesses","EditFile","item","content","GetFileContent","createReadStream","GetSingle","actualFilePath","downloadUrl","CreateFolder","disableNoClobber","newDir","newDirToAdd","ChangePermissions","isRecursive","tryChangePermissions","error_5","ChangePermissionsObject","tryChangePermissionsObject","UploadFile","originalname","bucketFilePath","desiredFile","CheckHasBodyProp","NgxFileMangerApiFireBaseClass","prototype","getBucket","bucketname","HandleList","HandleRename","newItemPath","HandleMove","HandleCopy","filesToCopy","singleFileName","HandleRemove","HandleEdit","HandleGetContent","error_8","HandleGetSingle","url","error_9","HandleCreateFolder","error_10","HandleSetPermissions","recursive","error_11","HandleSetPermissionsObject","error_12","HandleSaveFile","error_13","fmApi","express","LOGGING","endpoint","use","setHeader","origin","_c_id","LogRequest","form_1","formidable.IncomingForm","fields","fieldFileMap","fileArray","values","fs.readFile","fileBuffer","fs.unlinkSync","hash","convertToFileAndBuffer","convertedFiles","userClaims_1","userClaims","trySaveFile","results","success_1","finalResult","fullStack","returnedError","errorDetail","requestBody","bodyString","logging"],"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/ngx-filemanager-api-firebase/src/lib/endpoint/middleware-helpers.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/token-helper.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/permissions.factory.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/permissions-helper.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/permissions-queries.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/permissions-commands.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/permissions/index.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/utils/paths.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/utils/translation-helpers.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/utils/storage-helper.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/remove.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/getSingle.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/createFolder.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/changePermissions.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/uploadFile.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/changePermissionsObject.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/index.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/list.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/rename.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/move.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/copy.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/edit.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/commands/getContent.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/api/firebase-storage-api.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/endpoint/endpoint-express.ts","../../../projects/ngx-filemanager-api-firebase/src/lib/endpoint/middleware-upload.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Request, Response, NextFunction, RequestHandler } from 'express';\nconst cors = require('cors');\n\nexport function OptionRequestsAreOk(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): RequestHandler {\n  if (req.method === 'OPTIONS') {\n    console.log('Recieved OPTIONS request sending OK');\n    res.status(200).send('Options are OK\\n');\n    return;\n  }\n  next();\n}\n\nexport function PostRequestsOnly(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): RequestHandler {\n  if (req.method !== 'POST') {\n    const msg = 'Only POST requests are supported\\n';\n    console.warn(msg);\n    res.status(400).send(msg);\n    return;\n  }\n  next();\n}\n\nexport function HasBodyProp(bodyFieldName: string): RequestHandler {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.body[bodyFieldName]) {\n      const msg = `Request is missing property in req.body: \"${bodyFieldName}\" \\n`;\n      console.warn(msg);\n      res.status(400).send(msg);\n      return;\n    }\n    next();\n  };\n}\n\nexport function HasQueryParam(paramName: string): RequestHandler {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.query[paramName]) {\n      const msg = `Request is missing property in req.params: \"${paramName}\" \\n`;\n      console.warn(msg);\n      res.status(400).send(msg);\n      return;\n    }\n    next();\n  };\n}\n\nexport async function AddCors(req: Request, res: Response, next: NextFunction) {\n  res.setHeader(\n    'Access-Control-Allow-Headers',\n    'Authorization, X-Requested-With, Accept, Content-Type, Origin, Cache-Control, X-File-Name'\n  );\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  try {\n    await new Promise((resolve, reject) => {\n      cors({ origin: true })(req, res, () => {\n        resolve();\n      });\n    });\n    next();\n  } catch (error) {\n    throw new Error(error.message);\n  }\n}\n\nexport function LogRequest(req: Request, res: Response, next: NextFunction) {\n  const body = JSON.stringify(req.body || {}, null, 4).slice(0, 500);\n  const msg = `\n---- request: ${req.url}\nmethod: ${req.method}\n query: ${JSON.stringify(req.query, null, 4)}\n  body: ${body}\n----`;\n  console.log(msg);\n  next();\n}\n","import * as jwt from 'jsonwebtoken';\nimport { CoreTypes } from '../types';\n\nexport async function GetTokenFromRequest(req: Request) {\n  let idToken;\n  const isInHeader =\n    req.headers['authorization'] &&\n    req.headers['authorization'].startsWith('Bearer ');\n  const hasCookie = req['cookies'];\n\n  if (isInHeader) {\n    // Read the ID Token from the Authorization header.\n    idToken = req.headers['authorization'].split('Bearer ')[1];\n  } else if (hasCookie) {\n    // Read the ID Token from cookie.\n    idToken = req['cookies'].__session;\n  } else {\n    throw new Error(\n      'Request Header doesn\\'t contain a valid authorization bearer'\n    );\n  }\n\n  const decodedToken = await DecodeJWT(idToken);\n  return decodedToken as CoreTypes.UserCustomClaims;\n}\n\nexport async function DecodeJWT(bearer: string): Promise<{}> {\n  try {\n    const decoded = jwt.decode(bearer, { json: true });\n    return decoded;\n  } catch (error) {\n    throw new Error('Error decoding JWT' + error.message);\n  }\n}\n","import { CoreTypes } from '../types';\n\nfunction blankUserClaim(): CoreTypes.UserCustomClaims {\n  return {\n    groups: []\n  };\n}\n\nfunction blankPermissionsObj(): CoreTypes.FilePermissionsObject {\n  return {\n    others: 'read/write',\n    readers: [],\n    writers: []\n  };\n}\n\nexport const permsFactory = {\n  blankPermissionsObj,\n  blankUserClaim,\n};\n","import { VError } from 'verror';\nimport { File } from '../types/google-cloud-types';\nimport { SetMetadataResponse } from '@google-cloud/common';\n\nasync function SetMetaPropertyString(\n  file: File,\n  key: string,\n  newValueString: string\n): Promise<any> {\n  try {\n    const metaObj = { metadata: {} };\n    metaObj.metadata[key] = newValueString;\n    const res = await file.setMetadata(metaObj);\n    return res[0];\n  } catch (error) {\n    let fileExists: boolean;\n    try {\n      [fileExists] = await file.exists();\n    } catch (e) {\n      console.error(\n        'storage-helper: SetMetaProperty() error getting file.exists',\n        e\n      );\n    }\n    console.error('storage-helper: SetMetaProperty() error setting meta', {\n      fileExists,\n      filePath: file.name,\n      newValueString\n    });\n    throw new Error(error);\n  }\n}\n\nasync function SetMetaPropertyObj(\n  file: File,\n  key: string,\n  newValue: {}\n): Promise<{}> {\n  try {\n    const newValueString = JSON.stringify(newValue);\n    return SetMetaPropertyString(file, key, newValueString);\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n\nasync function GetMetaPropertyString(file: File, key: string): Promise<string> {\n  let newValueString;\n  try {\n    const [meta] = await file.getMetadata();\n    const metaData = meta.metadata || {};\n    newValueString = metaData[key] || null;\n    return newValueString;\n  } catch (error) {\n    try {\n      const [fileExists] = await file.exists();\n    } catch (error) {\n      console.error(error);\n    }\n    console.error('storage-helper: GetMetaProperty() error getting meta', {});\n    throw new VError(error);\n  }\n}\n\nasync function GetMetaPropertyObj<T>(file: File, key: string): Promise<T> {\n  let newValueString;\n  try {\n    newValueString = await GetMetaPropertyString(file, key);\n    const newValueObj = JSON.parse(newValueString);\n    return newValueObj;\n  } catch (error) {\n    console.error(\n      `could not convert the meta property \"${key}\" to a JSON object`,\n      error,\n      { newValueString }\n    );\n    throw new VError(error + ' error in JSON processing: ' + newValueString);\n  }\n}\n\nexport const permHelper = {\n  GetMetaPropertyObj: GetMetaPropertyObj,\n  SetMetaPropertyObj: SetMetaPropertyObj,\n  GetMetaPropertyString: GetMetaPropertyString,\n  SetMetaPropertyString: SetMetaPropertyString,\n};\n","import { File } from '../types/google-cloud-types';\nimport { GetTokenFromRequest } from './token-helper';\nimport { CoreTypes } from '../types';\nimport { permsFactory } from './permissions.factory';\nimport { VError } from 'verror';\nimport { permHelper } from './permissions-helper';\n\nasync function RetrieveFilePermissions(\n  file: File\n): Promise<CoreTypes.FilePermissionsObject> {\n  const fromStorage = await permHelper.GetMetaPropertyObj<CoreTypes.FilePermissionsObject>(\n    file,\n    'permissions'\n  );\n  const blank = permsFactory.blankPermissionsObj();\n  const safePerms = {\n    ...blank,\n    ...(fromStorage || {}),\n  };\n  return safePerms;\n}\n\nasync function RetrieveCustomClaims(req: Request) {\n  let token;\n  try {\n    token = await GetTokenFromRequest(req);\n  } catch (error) {\n    console.log('No bearer token found on request, no permissions for user');\n    return permsFactory.blankUserClaim();\n  }\n  const claims = token as CoreTypes.UserCustomClaims;\n  if (!claims.groups) {\n    claims.groups = [];\n  }\n  return claims;\n}\n\nfunction TryCheckHasAnyPermissions(claims: CoreTypes.UserCustomClaims) {\n  if (!claims.groups.length && !claims.userIsSudo) {\n    throw new Error('No user permissions found, cannot change permissions');\n  }\n}\n\nfunction CanRead(othersPermissions: CoreTypes.FilePermissionOthers) {\n  return (\n    othersPermissions == null ||\n    othersPermissions === 'read' ||\n    othersPermissions === 'read/write'\n  );\n}\n\nfunction CanWrite(othersPermissions: CoreTypes.FilePermissionOthers) {\n  return othersPermissions === 'read/write';\n}\n\nfunction CanOthersDo(\n  othersPermissions: CoreTypes.FilePermissionOthers,\n  toCheck: 'read' | 'write'\n) {\n  switch (toCheck) {\n    case 'read':\n      return CanRead(othersPermissions);\n    case 'write':\n      return CanWrite(othersPermissions);\n    default:\n      break;\n  }\n}\n\nexport type FilePermission = 'write' | 'read';\n\nfunction TryCheckFileAccess(\n  filePermissions: CoreTypes.FilePermissionsObject,\n  claims: CoreTypes.UserCustomClaims,\n  toCheck: 'read' | 'write'\n): boolean {\n  // Anyone can do something\n  const anyoneCanDo = CanOthersDo(filePermissions.others, toCheck);\n  if (anyoneCanDo) {\n    return true;\n  }\n  // Has no userclaims\n  const hasClaims = !!claims;\n  if (!hasClaims) {\n    return false;\n  }\n  // Sudo can do anything\n  const sudoCanDo = claims.userIsSudo;\n  if (sudoCanDo) {\n    return true;\n  }\n  const userAndGroups = [...claims.groups, claims.user_id];\n  let arrayToCheck;\n  if (toCheck === 'read') {\n    arrayToCheck = filePermissions.readers;\n  } else {\n    arrayToCheck = filePermissions.writers;\n  }\n  if (IsPartOfArray(arrayToCheck, userAndGroups)) {\n    return true;\n  }\n  return false;\n}\n\nfunction IsPartOfArray(\n  arr: CoreTypes.FilePermissionEntity[],\n  usersGroups: string[]\n) {\n  const hasNoGroupsToCheck = !usersGroups || !usersGroups.length;\n  if (hasNoGroupsToCheck) {\n    return false;\n  }\n  const userGroupSet = new Set(usersGroups);\n  const isInArray = arr.find((entity) => userGroupSet.has(entity));\n  return !!isInArray;\n}\n\nfunction CheckCanEditPermissions(\n  currentFilePermissions: CoreTypes.FilePermissionsObject,\n  newPermissions: CoreTypes.FilePermissionsObject,\n  claims: CoreTypes.UserCustomClaims\n) {\n  const canEditPermissions = TryCheckFileAccess(\n    currentFilePermissions,\n    claims,\n    'write'\n  );\n  const canEditPermissionsAfter = TryCheckFileAccess(\n    newPermissions,\n    claims,\n    'write'\n  );\n  if (!canEditPermissions) {\n    throw new VError('Cannot edit permissions here');\n  }\n  if (!canEditPermissionsAfter) {\n    throw new VError(\n      'Cannot change permissions, so you wont be able to change back'\n    );\n  }\n}\n\nexport const permsQueries = {\n  RetrieveFilePermissions,\n  RetrieveCustomClaims,\n  TryCheckHasAnyPermissions,\n  TryCheckFileAccess,\n  IsPartOfArray,\n  CheckCanEditPermissions,\n};\n","import { File } from '../types/google-cloud-types';\nimport { CoreTypes } from '../types';\nimport { permHelper } from './permissions-helper';\n\nasync function UpdateFilePermissions(\n  file: File,\n  newPermissions: CoreTypes.FilePermissionsObject\n) {\n  return permHelper.SetMetaPropertyObj(file, 'permissions', newPermissions);\n}\n\nexport const permsCommands = {\n  UpdateFilePermissions\n};\n","import { permsQueries } from './permissions-queries';\nimport { permsFactory } from './permissions.factory';\nimport { permsCommands } from './permissions-commands';\n\nexport const perms = {\n  factory: permsFactory,\n  commands: permsCommands,\n  queries: permsQueries,\n};\n","import * as path from 'path';\n\nfunction HasPrefixSlash(inputPath: string): boolean {\n  if (!inputPath || !inputPath.length) {\n    return false;\n  }\n  const hasPrefix = inputPath.startsWith('/');\n  return hasPrefix;\n}\n\nfunction HasTrailingSlash(inputPath: string): boolean {\n  if (!inputPath || !inputPath.length) {\n    return false;\n  }\n  const hasTrailing = inputPath.endsWith('/');\n  return hasTrailing;\n}\n\nfunction EnsureTrailingSlash(inputPath: string): string {\n  if (!inputPath) {\n    return '/';\n  }\n  const hasTrailing = HasTrailingSlash(inputPath);\n  const pathParsed = hasTrailing ? inputPath : inputPath + '/';\n  return pathParsed;\n}\n\nfunction EnsureNoPrefixSlash(inputPath: string): string {\n  const hasPrefix = HasPrefixSlash(inputPath);\n  const pathParsed = hasPrefix ? inputPath.slice(1) : inputPath;\n  return pathParsed;\n}\n\nfunction EnsurePrefixSlash(inputPath: string): string {\n  if (!inputPath) {\n    return '/';\n  }\n  const hasPrefix = HasPrefixSlash(inputPath);\n  const pathParsed = hasPrefix ? inputPath : '/' + inputPath;\n  return pathParsed;\n}\n\nfunction EnsureNoTrailingSlash(inputPath: string): string {\n  const hasTrailing = HasTrailingSlash(inputPath);\n  const pathParsed = hasTrailing ? inputPath.slice(0, -1) : inputPath;\n  return pathParsed;\n}\n\nfunction EnsureAbsolutePathFile(filePath: string) {\n  return EnsurePrefixSlash(EnsureNoTrailingSlash(filePath));\n}\n\nfunction EnsureAbsolutePathDir(folderPath: string) {\n  return EnsurePrefixSlash(EnsureTrailingSlash(folderPath));\n}\n\nfunction EnsureGoogleStoragePathDir(folderPath: string) {\n  return EnsureNoPrefixSlash(EnsureTrailingSlash(folderPath));\n}\n\nfunction EnsureGoogleStoragePathFile(filePath: string) {\n  return EnsureNoPrefixSlash(EnsureNoTrailingSlash(filePath));\n}\n\nfunction GetRelativePath(\n  currentDirectoryPath: string,\n  absObjectPath: string\n): string {\n  const relativePath = absObjectPath.slice(currentDirectoryPath.length);\n  return relativePath;\n}\n\nfunction GetParentDir(currentDirectoryPath: string): string {\n  const parsed = EnsurePrefixSlash(currentDirectoryPath);\n  const parentPath = path.dirname(parsed);\n  return EnsureGoogleStoragePathDir(parentPath);\n}\n\nfunction IsCurrentPath(\n  currentDirectoryPath: string,\n  absObjectPath: string\n): boolean {\n  const relativePath = GetRelativePath(currentDirectoryPath, absObjectPath);\n  const isCurrentDir = !relativePath;\n  return isCurrentDir;\n}\n\nfunction IsCurrentPathFile(\n  currentDirectoryPath: string,\n  absObjectPath: string\n): boolean {\n  const relativePath = GetRelativePath(currentDirectoryPath, absObjectPath);\n  const slashSegments = relativePath.split('/');\n  const isCurrentPathFile = slashSegments.length < 2;\n  return isCurrentPathFile;\n}\n\nfunction IsObjNameDir(storageObjectName: string) {\n  const filePathParsed = EnsurePrefixSlash(storageObjectName);\n  const isDir = HasTrailingSlash(filePathParsed);\n  return isDir;\n}\n\nfunction IsObjNameFile(storageObjectName: string) {\n  return !IsObjNameDir(storageObjectName);\n}\n\nfunction GetSubDirectory(\n  currentDirectoryPath: string,\n  absObjectPath: string\n): string {\n  const relativePath = GetRelativePath(currentDirectoryPath, absObjectPath);\n  const slashSegments = relativePath.split('/');\n  const subDirectory = slashSegments.shift();\n  return subDirectory;\n}\n\nfunction Add2ToPath(inputPath: string): string {\n  const dotSegments = inputPath.split('.');\n  const extension = dotSegments.pop();\n  const fileName = dotSegments.join('.') + ' (2)' + '.' + extension;\n  return fileName;\n}\n\nfunction Add2ToPathDir(inputPath: string): string {\n  const pathWithoutSlash = EnsureNoTrailingSlash(inputPath);\n  const pathWith2 = pathWithoutSlash + ' (2)';\n  const newDirName =  EnsureTrailingSlash(pathWith2);\n  return newDirName;\n}\n\nfunction GetFileNameWithExtension(inputPath: string): string {\n  const fileNameWithExt = inputPath.split('/').pop();\n  return fileNameWithExt;\n}\n\nfunction GetFileNameWithoutExtension(inputPath: string): string {\n  const fileNameWithExt = GetFileNameWithExtension(inputPath);\n  const segments = fileNameWithExt.split('.');\n  segments.pop(); // remove extension\n  return segments.join('.');\n}\n\nfunction GetPathUpToLastBracket(inputPath: string): string {\n  const slashes = inputPath.split('/');\n  slashes.pop();\n  const dirPath = slashes.join('/');\n  const fileName = inputPath.slice(dirPath.length);\n  const bracketSegments = fileName.split('(');\n  bracketSegments.pop();\n  const fileNameWith = bracketSegments.join('(');\n  if (fileName.includes('(')) {\n    const filepathWithBracket = path.join(dirPath, fileNameWith + '(');\n    return filepathWithBracket;\n  }\n  const dotSegments = inputPath.split('.');\n  if (dotSegments.length < 2) {\n    return inputPath;\n  }\n  dotSegments.pop();\n  return dotSegments.join('.');\n}\n\nexport const paths = {\n  HasPrefixSlash,\n  HasTrailingSlash,\n  EnsureTrailingSlash,\n  EnsureNoPrefixSlash,\n  EnsurePrefixSlash,\n  EnsureNoTrailingSlash,\n  EnsureAbsolutePathFile,\n  EnsureAbsolutePathDir,\n  EnsureGoogleStoragePathDir,\n  EnsureGoogleStoragePathFile,\n  GetRelativePath,\n  IsCurrentPath,\n  IsCurrentPathFile,\n  IsObjNameDir,\n  IsObjNameFile,\n  GetSubDirectory,\n  GetParentDir,\n  GetFileNameWithExtension,\n  GetFileNameWithoutExtension,\n  GetPathUpToLastBracket,\n  Add2ToPath,\n  Add2ToPathDir\n};\n","import { FileFromStorage, File } from '../types/google-cloud-types';\nimport { Readable } from 'stream';\nimport * as request from 'request';\nimport * as path from 'path';\nimport { VError } from 'verror';\nimport { perms } from '../permissions';\nimport { paths } from './paths';\nimport { CoreTypes } from '../types';\n\nexport function translateRawStorage(storageObject: File): FileFromStorage {\n  const filePath = storageObject.name;\n  const filePathParsed = paths.EnsurePrefixSlash(filePath);\n  return {\n    ref: storageObject,\n    name: path.basename(filePathParsed),\n    fullPath: filePathParsed,\n    isDir: paths.HasTrailingSlash(filePathParsed)\n  };\n}\n\nexport function makePhantomStorageFolder(folderPath: string): FileFromStorage {\n  const pathParsed = paths.EnsureAbsolutePathDir(folderPath);\n  return {\n    ref: null,\n    name: path.basename(pathParsed),\n    fullPath: pathParsed,\n    isDir: true,\n    isPhantomFolder: true\n  };\n}\n\nexport async function translateStorageToResFile(\n  f: FileFromStorage\n): Promise<CoreTypes.ResFile> {\n  const resFile: CoreTypes.ResFile = {} as any;\n  resFile.name = f.name;\n  if (f.isDir) {\n    resFile.type = 'dir';\n    resFile.fullPath = paths.EnsureAbsolutePathDir(f.fullPath);\n  } else {\n    resFile.type = 'file';\n    resFile.fullPath = paths.EnsureAbsolutePathFile(f.fullPath);\n  }\n  if (f.isPhantomFolder) {\n    resFile.permissions = perms.factory.blankPermissionsObj();\n    resFile.isPhantomFolder = true;\n    return resFile;\n  }\n  try {\n    const [exists] = await f.ref.exists();\n    if (!exists) {\n      throw new Error('File not found: ' + resFile.fullPath);\n    }\n    const [aclObj] = await f.ref.acl.get();\n    resFile.rightsFirebase = aclObj as any;\n    const metaResp = await f.ref.getMetadata();\n    const metaData = metaResp[0];\n    const customMeta = metaData.metadata || {};\n    const permissions = await perms.queries.RetrieveFilePermissions(f.ref);\n    resFile.permissions = permissions;\n    resFile.size = metaData.size;\n    resFile.date = metaData.updated;\n    resFile.metaData = customMeta;\n    return resFile;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function StreamToPromise(stream: Readable): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    let stringRes: string;\n    stream.on('readable', function(buffer) {\n      const part: string = buffer.read().toString() as string;\n      stringRes += part;\n      console.log('stream data ' + part);\n    });\n    stream.on('end', res => {\n      resolve(stringRes);\n    });\n    stream.on('error', err => {\n      const errmsg =\n        'StreamToPromise(stream: Readable), Error reading stream: ' +\n        err.message;\n      console.error(errmsg, { err });\n      reject(errmsg);\n    });\n  });\n}\n\nexport function getResult(res: request.Response): CoreTypes.ResultObj {\n  const fail = res.statusCode !== 204;\n  return {\n    success: !fail,\n    error: fail ? 'error: ' + res.body : null\n  };\n}\n\nexport function getResultFromArray(\n  res: request.Response[]\n): CoreTypes.ResultObj {\n  const fail = res.find(r => r.statusCode !== 204);\n  return {\n    success: !fail,\n    error: fail ? 'error: ' + JSON.stringify(fail.body) : null\n  };\n}\n\nexport function ResultsObjFromArray(\n  moveResults: CoreTypes.ResultObj[]\n): CoreTypes.ResultObj {\n  return moveResults.reduce(\n    (acc, cur) => {\n      if (cur.error) {\n        acc.error += ' | ' + cur.error;\n        acc.success = false;\n      }\n      return acc;\n    },\n    { error: '', success: true }\n  );\n}\n","import * as path from 'path';\nimport * as request from 'request';\nimport { VError } from 'verror';\nimport { GetFilesOptions } from '@google-cloud/storage';\n\nimport { Bucket, File, FileFromStorage } from '../types/google-cloud-types';\nimport { paths } from './paths';\nimport { perms } from '../permissions';\nimport { CoreTypes } from '../types';\nimport {\n  translateStorageToResFile,\n  makePhantomStorageFolder,\n  translateRawStorage\n} from './translation-helpers';\n\nasync function GetAllChildrenWithPrefix(\n  bucket: Bucket,\n  fileOrDirectoryPath: string\n): Promise<File[]> {\n  const pathNoPrefix = paths.EnsureNoPrefixSlash(fileOrDirectoryPath);\n  const options: GetFilesOptions = {};\n  options.prefix = pathNoPrefix;\n  try {\n    const result = await bucket.getFiles(options);\n    const files = result[0];\n    return files;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nasync function TryRenameFile(\n  file: File,\n  oldPrefix: string,\n  newPrefix: string\n): Promise<CoreTypes.ResultObj> {\n  try {\n    const originalFilePath = file.name;\n    const relativePath = originalFilePath.slice(oldPrefix.length);\n    const newPath = path.join(newPrefix, relativePath);\n    const newFilePath = paths.EnsureNoPrefixSlash(newPath);\n    console.log(`- renaming \"${originalFilePath}\" -> \"${newFilePath}\"`);\n    const [response] = await file.move(newFilePath);\n    return { error: '', success: true };\n  } catch (error) {\n    const [fileExists] = await file.exists();\n    console.error('storage-helper: TryCopyFile() error renaming file', {\n      fileExists,\n      fileName: file.name,\n      oldPrefix,\n      newPrefix\n    });\n    throw new VError(error);\n  }\n}\n\nasync function TryCopyFile(file: File, oldPrefix: string, newPrefix: string) {\n  try {\n    const originalFilePath = file.name;\n    const relativePath = originalFilePath.slice(oldPrefix.length);\n    const newPath = path.join(newPrefix, relativePath);\n    const newFilePath = paths.EnsureNoPrefixSlash(newPath);\n    console.log(`- copying \"${originalFilePath}\" -> \"${newFilePath}\"`);\n    const result = await file.copy(newFilePath);\n    return result[1];\n  } catch (error) {\n    const [fileExists] = await file.exists();\n    console.error('storage-helper: TryCopyFile() error copying file', {\n      fileExists\n    });\n    throw new VError(error);\n  }\n}\n\nasync function TryCheckWritePermission(\n  bucket: Bucket,\n  newDirPath: string,\n  claims: CoreTypes.UserCustomClaims\n): Promise<any> {\n  try {\n    const parentPath = paths.GetParentDir(newDirPath);\n    const isRoot = parentPath === '';\n    if (isRoot) {\n      return;\n    }\n    const parentDir = bucket.file(parentPath);\n    const [fileExists] = await parentDir.exists();\n    if (!fileExists) {\n      return TryCheckWritePermission(bucket, parentPath, claims);\n    }\n    const parentPermissions = await perms.queries.RetrieveFilePermissions(\n      parentDir\n    );\n    const result = perms.queries.TryCheckFileAccess(\n      parentPermissions,\n      claims,\n      'write'\n    );\n    if (!result) {\n      throw new Error(\n        'Permission denied creating item in directory:' + parentPath\n      );\n    }\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n\n// LIST\n\ninterface FilesAndPrefixes {\n  files: File[];\n  prefixes: string[];\n}\n\nexport function MakeOptionsListRoot(): GetFilesOptions {\n  return {\n    delimiter: '/',\n    includeTrailingDelimiter: true,\n    autoPaginate: false\n  } as any;\n}\n\nexport function MakeOptionsList(inputDirectoryPath: string) {\n  return {\n    delimiter: '/',\n    includeTrailingDelimiter: true,\n    directory: inputDirectoryPath,\n    autoPaginate: false\n  } as any;\n}\n\nexport async function GetFilesAndPrefixes(\n  bucket: Bucket,\n  options: GetFilesOptions\n): Promise<FilesAndPrefixes> {\n  return new Promise<FilesAndPrefixes>((resolve, reject) => {\n    const callback = (\n      err: Error | null,\n      files?: File[],\n      nextQuery?: {},\n      apiResponse?: request.Response\n    ) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      const prefixes = apiResponse['prefixes'] || [];\n      const result: FilesAndPrefixes = {\n        files: files || [],\n        prefixes: prefixes\n      };\n      resolve(result);\n    };\n    bucket.getFiles(options, callback);\n  });\n}\n\nexport async function GetFiles(\n  bucket: Bucket,\n  options: GetFilesOptions\n): Promise<FileFromStorage[]> {\n  try {\n    const result = await bucket.getFiles(options);\n    const storageObjects = result[0];\n    const files = storageObjects.map(o => translateRawStorage(o));\n    return files;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function GetListFromStorage(\n  bucket: Bucket,\n  inputDirectoryPath: string\n): Promise<FileFromStorage[]> {\n  const googleStorageDirPath = paths.EnsureGoogleStoragePathDir(\n    inputDirectoryPath\n  );\n  const isRootPath = googleStorageDirPath === '/' || '';\n  let options;\n  if (isRootPath) {\n    options = MakeOptionsListRoot();\n  } else {\n    options = MakeOptionsList(googleStorageDirPath);\n  }\n  try {\n    const result = await GetFilesAndPrefixes(bucket, options);\n    const allObjects = result.files.map(o => translateRawStorage(o));\n\n    const allObjectsPathsSet = new Set(allObjects.map(f => f.ref.name));\n    const phantomPrefixes = result.prefixes.filter(\n      prefix => !allObjectsPathsSet.has(prefix)\n    );\n\n    const newPhantomFolders = phantomPrefixes.map(phantomPath =>\n      makePhantomStorageFolder(phantomPath)\n    );\n    const combinedList = [...allObjects, ...newPhantomFolders];\n    const filesWithoutCurrentDirectory = combinedList.filter(\n      f => paths.EnsureGoogleStoragePathDir(f.fullPath) !== googleStorageDirPath\n    );\n    return filesWithoutCurrentDirectory;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function GetListWithoutPermissions(\n  bucket: Bucket,\n  inputDirectoryPath: string\n): Promise<CoreTypes.ResFile[]> {\n  try {\n    const files = await GetListFromStorage(bucket, inputDirectoryPath);\n    const resFiles = await Promise.all(\n      files.map(f => translateStorageToResFile(f))\n    );\n    return resFiles;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport const storage = {\n  GetListWithoutPermissions,\n  GetAllChildrenWithPrefix,\n  MakeOptionsListRoot,\n  MakeOptionsList,\n  TryRenameFile,\n  TryCopyFile,\n  TryCheckWritePermission\n};\n","import { Bucket, File } from '../../types/google-cloud-types';\nimport { VError } from 'verror';\nimport { paths } from '../../utils/paths';\nimport { CoreTypes } from '../../types';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function tryDeleteFile(file: File): Promise<boolean> {\n  try {\n    const [exists] = await file.exists();\n    if (exists) {\n      console.log('- deleting file: ', file.name);\n      await file.delete();\n      return true;\n    }\n    return false;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function RemoveFileWithChildren(\n  bucket: Bucket,\n  itemPath: string\n): Promise<boolean> {\n  try {\n    const allChildren = await storage.GetAllChildrenWithPrefix(bucket, itemPath);\n    const successArray = await Promise.all(\n      allChildren.map(f => tryDeleteFile(f))\n    );\n    const allSuccesses = successArray.reduce(\n      (acc, cur) => (acc = acc && cur),\n      true\n    );\n    return allSuccesses;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function RemoveFiles(\n  bucket: Bucket,\n  items: string[],\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const googleStorageItemPaths = items.map(p => paths.EnsureNoPrefixSlash(p));\n    const successArray = await Promise.all(\n      googleStorageItemPaths.map(itemPath =>\n        RemoveFileWithChildren(bucket, itemPath)\n      )\n    );\n    const allSuccesses = successArray.reduce(\n      (acc, cur) => (acc = acc && cur),\n      true\n    );\n    const results: CoreTypes.ResultObj = {\n      success: allSuccesses\n    };\n    return results;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket, File } from '../../types/google-cloud-types';\nimport { GetSignedUrlConfig } from '@google-cloud/storage';\nimport { VError } from 'verror';\nimport { CoreTypes } from '../../types';\nimport {\n  translateStorageToResFile,\n  translateRawStorage\n} from '../../utils/translation-helpers';\nimport { paths } from '../../utils/paths';\nconst moment = require('moment');\n\nasync function GetUrl(file: File): Promise<string> {\n  try {\n    const in5mins = moment()\n      .add(5, 'minutes')\n      .toDate();\n    const config: GetSignedUrlConfig = { expires: in5mins, action: 'read' };\n    const signedResult = await file.getSignedUrl(config);\n    const url = signedResult.shift();\n    return url;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function GetSingle(\n  bucket: Bucket,\n  item: string,\n  claims: CoreTypes.UserCustomClaims\n): Promise<CoreTypes.ResFile> {\n  try {\n    const actualFilePath = paths.EnsureNoPrefixSlash(item);\n    const file = bucket.file(actualFilePath);\n    const translatedF = translateRawStorage(file);\n    const resFile = await translateStorageToResFile(translatedF);\n    resFile.downloadUrl = await GetUrl(file);\n    return resFile;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket, File } from '../../types/google-cloud-types';\nimport { CoreTypes } from '../../types';\nimport { paths } from '../../utils/paths';\nimport { storage } from '../../utils/storage-helper';\nimport { perms } from '../../permissions';\n\nexport async function CreateFolderWithoutPermissions(\n  bucket: Bucket,\n  newDirectoryPath: string\n) {\n  const directoryPath = paths.EnsureGoogleStoragePathDir(newDirectoryPath);\n  const file = bucket.file(directoryPath);\n  const result = { success: true };\n  try {\n    await file.save('');\n    const blankPerms = perms.factory.blankPermissionsObj();\n    await perms.commands.UpdateFilePermissions(file, blankPerms);\n  } catch (error) {\n    result.success = false;\n  }\n  return result;\n}\n\nexport async function GetNextFreeFoldername(\n  bucket: Bucket,\n  targetChildDir: File\n): Promise<File> {\n  const parentDirectory = paths.GetParentDir(targetChildDir.name);\n  const childrenMatching = await storage.GetListWithoutPermissions(\n    bucket,\n    parentDirectory\n  );\n  const isEmptyParent = !childrenMatching || !childrenMatching.length;\n  if (isEmptyParent) {\n    return targetChildDir;\n  }\n  const childrenMatchingPaths = childrenMatching.map(f =>\n    paths.EnsureGoogleStoragePathDir(f.fullPath)\n  );\n  const targetFolderPath = paths.EnsureGoogleStoragePathDir(targetChildDir.name);\n  const folderExists = childrenMatchingPaths.some(\n    path => path === targetFolderPath\n  );\n  if (!folderExists) {\n    return targetChildDir;\n  }\n  const nextPath = paths.Add2ToPathDir(targetFolderPath);\n  const nextFreeFile = bucket.file(nextPath);\n  return nextFreeFile;\n}\n\nexport async function CreateFolder(\n  bucket: Bucket,\n  newDirectoryPath: string,\n  claims: CoreTypes.UserCustomClaims,\n  disableNoClobber?: boolean,\n  isAdmin?: boolean,\n) {\n  try {\n    const newDirPath = paths.EnsureGoogleStoragePathDir(newDirectoryPath);\n    const newDir = bucket.file(newDirPath);\n    let newDirToAdd: File;\n    if (!disableNoClobber) {\n      newDirToAdd = await GetNextFreeFoldername(bucket, newDir);\n    } else {\n      newDirToAdd = newDir;\n    }\n    if (!isAdmin) {\n      await storage.TryCheckWritePermission(bucket, newDirToAdd.name, claims);\n    }\n    return CreateFolderWithoutPermissions(bucket, newDirToAdd.name);\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n","import { File } from '../../types/google-cloud-types';\nimport { Bucket } from '@google-cloud/storage';\nimport * as request from 'request';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\nimport { perms } from '../../permissions';\nimport { storage } from '../../utils/storage-helper';\n\nexport function SetPermissionToObj(\n  permissionsObj: CoreTypes.FilePermissionsObject,\n  role: CoreTypes.PermissionsRole,\n  entity: CoreTypes.FilePermissionEntity\n): CoreTypes.FilePermissionsObject {\n  const newPermissions = {\n    ...perms.factory.blankPermissionsObj(),\n    ...permissionsObj\n  };\n  if (role === 'READER') {\n    if (!newPermissions.readers.includes(entity)) {\n      newPermissions.readers.push(entity);\n    }\n  }\n  if (role === 'WRITER') {\n    if (!newPermissions.writers.includes(entity)) {\n      newPermissions.writers.push(entity);\n    }\n  }\n  return newPermissions;\n}\n\nexport async function ChangeSingleFilePermissionsAsSudo(\n  file: File,\n  role: CoreTypes.PermissionsRole,\n  entity: CoreTypes.FilePermissionEntity\n) {\n  try {\n    const currentFilePermissions = await perms.queries.RetrieveFilePermissions(\n      file\n    );\n    const newPermissions = SetPermissionToObj(\n      currentFilePermissions,\n      role,\n      entity\n    );\n    const res = await perms.commands.UpdateFilePermissions(\n      file,\n      newPermissions\n    );\n    return res;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function TryChangeSingleFilePermissions(\n  file: File,\n  role: CoreTypes.PermissionsRole,\n  entity: CoreTypes.FilePermissionEntity,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const currentFilePermissions = await perms.queries.RetrieveFilePermissions(\n      file\n    );\n    const newPermissions = SetPermissionToObj(\n      currentFilePermissions,\n      role,\n      entity\n    );\n    perms.queries.CheckCanEditPermissions(\n      currentFilePermissions,\n      newPermissions,\n      claims\n    );\n    const res = await perms.commands.UpdateFilePermissions(\n      file,\n      newPermissions\n    );\n    return res;\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n\nasync function tryChangePermissions(\n  bucket: Bucket,\n  filePath: string,\n  role: CoreTypes.PermissionsRole,\n  entity: CoreTypes.FilePermissionEntity,\n  isRecursive: boolean,\n  claims: CoreTypes.UserCustomClaims\n): Promise<{}[]> {\n  if (isRecursive) {\n    try {\n      const allChildren = await storage.GetAllChildrenWithPrefix(\n        bucket,\n        filePath\n      );\n      const successArray = await Promise.all(\n        allChildren.map(file =>\n          TryChangeSingleFilePermissions(file, role, entity, claims)\n        )\n      );\n      return successArray;\n    } catch (error) {\n      throw new VError(error);\n    }\n  } else {\n    try {\n      const file = bucket.file(filePath);\n      const result = await TryChangeSingleFilePermissions(\n        file,\n        role,\n        entity,\n        claims\n      );\n      return [result];\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n}\n\nexport async function ChangePermissions(\n  bucket: Bucket,\n  items: string[],\n  role: CoreTypes.PermissionsRole,\n  entity: CoreTypes.FilePermissionEntity,\n  isRecursive: boolean,\n  claims: CoreTypes.UserCustomClaims\n): Promise<CoreTypes.ResultObj> {\n  try {\n    // perms.queries.TryCheckHasAnyPermissions(claims);\n    const successArr = await Promise.all(\n      items.map(filePath =>\n        tryChangePermissions(\n          bucket,\n          filePath,\n          role,\n          entity,\n          isRecursive,\n          claims\n        )\n      )\n    );\n    // return results;\n    return {\n      success: successArr as any\n    };\n  } catch (error) {\n    throw new Error(error.message);\n  }\n}\n","import { Bucket, File } from '../../types/google-cloud-types';\nimport * as path from 'path';\nimport { CoreTypes } from '../../types';\nimport { paths } from '../../utils/paths';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function SaveBufferToPath(\n  file: File,\n  mimetype: string,\n  buffer: Buffer\n) {\n  const fileOptions = {\n    contentType: mimetype\n  };\n  console.log('uploadFile: SaveBufferToPath', { mimetype, path: file.name });\n  return file.save(buffer, fileOptions);\n}\n\nexport async function GetNextFreeFilename(\n  bucket: Bucket,\n  inputFile: File\n): Promise<File> {\n  const dirNameNoSuffix = paths.GetParentDir(inputFile.name);\n  const childrenMatching = await storage.GetListWithoutPermissions(\n    bucket,\n    dirNameNoSuffix\n  );\n  if (!childrenMatching || !childrenMatching.length) {\n    return inputFile;\n  }\n  const matchingNames = childrenMatching.map(f => f.fullPath).sort();\n  const lastMatch = matchingNames.shift();\n  const nextPath = paths.Add2ToPath(lastMatch);\n  const nextFreeFile = bucket.file(nextPath);\n  return nextFreeFile;\n}\n\nexport async function UploadFile(\n  bucket: Bucket,\n  directoryPath: string,\n  originalname: string,\n  mimetype: string,\n  buffer: Buffer,\n  claims: CoreTypes.UserCustomClaims\n) {\n  const newPath = path.join(directoryPath, originalname);\n  const bucketFilePath = paths.EnsureGoogleStoragePathFile(newPath);\n  const desiredFile = bucket.file(bucketFilePath);\n  try {\n    let file: File;\n    const [exists] = await desiredFile.exists();\n    if (exists) {\n      file = await GetNextFreeFilename(bucket, desiredFile);\n    } else {\n      file = desiredFile;\n    }\n    await SaveBufferToPath(file, mimetype, buffer);\n  } catch (error) {\n    throw new Error('UploadFile: ' + error);\n  }\n}\n","import { File } from '../../types/google-cloud-types';\nimport { Bucket } from '@google-cloud/storage';\nimport * as request from 'request';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\nimport { perms } from '../../permissions';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function TryChangeSingleFilePermissionsObject(\n  file: File,\n  newPermissions: CoreTypes.FilePermissionsObject,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    // Disabled for new Admin Flag in config\n    // const currentFilePermissions = await perms.queries.RetrieveFilePermissions(\n    //   file\n    // );\n    // perms.queries.CheckCanEditPermissions(\n    //   currentFilePermissions,\n    //   newPermissions,\n    //   claims\n    // );\n    const res = await perms.commands.UpdateFilePermissions(\n      file,\n      newPermissions\n    );\n    return res;\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n\nasync function tryChangePermissionsObject(\n  bucket: Bucket,\n  filePath: string,\n  permissionsObj: CoreTypes.FilePermissionsObject,\n  isRecursive: boolean,\n  claims: CoreTypes.UserCustomClaims\n): Promise<{}[]> {\n  if (isRecursive) {\n    try {\n      const allChildren = await storage.GetAllChildrenWithPrefix(\n        bucket,\n        filePath\n      );\n      const successArray = await Promise.all(\n        allChildren.map(file =>\n          TryChangeSingleFilePermissionsObject(file, permissionsObj, claims)\n        )\n      );\n      return successArray;\n    } catch (error) {\n      throw new VError(error);\n    }\n  } else {\n    try {\n      const file = bucket.file(filePath);\n      const result = await TryChangeSingleFilePermissionsObject(\n        file,\n        permissionsObj,\n        claims\n      );\n      return [result];\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n}\n\nexport async function ChangePermissionsObject(\n  bucket: Bucket,\n  items: string[],\n  permissionsObj: CoreTypes.FilePermissionsObject,\n  isRecursive: boolean,\n  claims: CoreTypes.UserCustomClaims\n): Promise<CoreTypes.ResultObj> {\n  try {\n    const successArr = await Promise.all(\n      items.map(filePath =>\n        tryChangePermissionsObject(\n          bucket,\n          filePath,\n          permissionsObj,\n          isRecursive,\n          claims\n        )\n      )\n    );\n    return {\n      success: successArr as any\n    };\n  } catch (error) {\n    throw new Error(error.message);\n  }\n}\n","import { GetList } from './list';\nimport { RenameFile } from './rename';\nimport { MoveFiles } from './move';\nimport { CopyFiles } from './copy';\nimport { RemoveFiles } from './remove';\nimport { EditFile } from './edit';\nimport { GetFileContent } from './getContent';\nimport { GetSingle } from './getSingle';\nimport { CreateFolder } from './createFolder';\nimport { ChangePermissions } from './changePermissions';\nimport { UploadFile } from './uploadFile';\nimport { ChangePermissionsObject } from './changePermissionsObject';\n\nexport const commands = {\n  GetList,\n  RenameFile,\n  MoveFiles,\n  CopyFiles,\n  RemoveFiles,\n  EditFile,\n  GetFileContent,\n  GetSingle,\n  CreateFolder,\n  ChangePermissions,\n  ChangePermissionsObject,\n  UploadFile\n};\n","import { Bucket } from '../../types/google-cloud-types';\nimport { VError } from 'verror';\nimport { perms } from '../../permissions';\nimport { CoreTypes } from '../../types';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function GetList(\n  bucket: Bucket,\n  inputDirectoryPath: string,\n  claims: CoreTypes.UserCustomClaims,\n  isAdmin?: boolean\n): Promise<CoreTypes.ResFile[]> {\n  try {\n    const resFiles = await storage.GetListWithoutPermissions(\n      bucket,\n      inputDirectoryPath\n    );\n    if (isAdmin) {\n      return resFiles;\n    }\n    const filesAllowed = resFiles.filter(f => {\n      return perms.queries.TryCheckFileAccess(f.permissions, claims, 'read');\n    });\n    return filesAllowed;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket } from '../../types/google-cloud-types';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\nimport { paths } from '../../utils/paths';\nimport { storage } from '../../utils/storage-helper';\nimport { ResultsObjFromArray } from '../../utils/translation-helpers';\n\nexport async function RenameFile(\n  bucket: Bucket,\n  inputSrc: string,\n  inputDest: string,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const parsedSrc = paths.EnsureNoPrefixSlash(inputSrc);\n    const parsedDest = paths.EnsureNoPrefixSlash(inputDest);\n    const fileItem = bucket.file(parsedSrc);\n    const [exists] = await fileItem.exists();\n    if (!exists) {\n      throw new Error(`\nitem: \"${fileItem.name}\" does not exist\nbucket: \"${bucket.name}\"\n\ninputSrc: \"${inputSrc}\",\ninputDest: \"${inputDest}\",\n\nparsedSrc: \"${parsedSrc}\",\nparsedDest: \"${parsedDest}\",\n`);\n    }\n    const isFile = !inputSrc.endsWith('/');\n    if (isFile) {\n      const resultObj = await storage.TryRenameFile(\n        fileItem,\n        parsedSrc,\n        parsedDest\n      );\n      return resultObj;\n    }\n    const allChildren = await storage.GetAllChildrenWithPrefix(\n      bucket,\n      parsedSrc\n    );\n    const moveResults = await Promise.all(\n      allChildren.map(f => storage.TryRenameFile(f, parsedSrc, parsedDest))\n    );\n    return ResultsObjFromArray(moveResults);\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket } from '../../types/google-cloud-types';\nimport { ResultsObjFromArray } from '../../utils/translation-helpers';\nimport * as path from 'path';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\nimport { paths } from '../../utils/paths';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function moveWithChildren(\n  bucket: Bucket,\n  itemPath: string,\n  newFolderPrefix: string\n) {\n  try {\n    const oldFolderPrefix = paths.EnsureNoPrefixSlash(path.dirname(itemPath));\n    const allChildren = await storage.GetAllChildrenWithPrefix(bucket, itemPath);\n    const successArray = await Promise.all(\n      allChildren.map(f => storage.TryRenameFile(f, oldFolderPrefix, newFolderPrefix))\n    );\n    return successArray;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function MoveFiles(\n  bucket: Bucket,\n  items: string[],\n  newDirectoryPath: string,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const newFolderPrefix = paths.EnsureGoogleStoragePathDir(newDirectoryPath);\n    const moveResultsArrArr = await Promise.all(\n      items.map(filePath => moveWithChildren(bucket, filePath, newFolderPrefix))\n    );\n    const moveResultsArr = moveResultsArrArr.reduce((acc, cur) => {\n      return acc.concat(cur);\n    }, []);\n    return ResultsObjFromArray(moveResultsArr);\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket } from '../../types/google-cloud-types';\nimport { getResultFromArray } from '../../utils/translation-helpers';\nimport * as path from 'path';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\nimport { paths } from '../../utils/paths';\nimport { storage } from '../../utils/storage-helper';\n\nexport async function copyWithChildren(\n  bucket: Bucket,\n  itemPath: string,\n  newFolderPrefix: string\n) {\n  try {\n    const oldFolderPrefix = paths.EnsureNoPrefixSlash(path.dirname(itemPath));\n    const allChildren = await storage.GetAllChildrenWithPrefix(bucket, itemPath);\n    const successArray = await Promise.all(\n      allChildren.map(f => storage.TryCopyFile(f, oldFolderPrefix, newFolderPrefix))\n    );\n    return successArray;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n\nexport async function CopyFiles(\n  bucket: Bucket,\n  items: string[],\n  newDirectoryPath: string,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const newFolderPrefix = paths.EnsureGoogleStoragePathDir(newDirectoryPath);\n    const copyResultsArrArr = await Promise.all(\n      items.map(filePath => copyWithChildren(bucket, filePath, newFolderPrefix))\n    );\n    const copyResultsArr = copyResultsArrArr.reduce((acc, cur) => {\n      return acc.concat(cur);\n    }, []);\n    const results = getResultFromArray(copyResultsArr);\n    return results;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Bucket } from '../../types/google-cloud-types';\nimport { CoreTypes } from '../../types';\n\nexport async function EditFile(\n  bucket: Bucket,\n  item: string,\n  content: string,\n  claims: CoreTypes.UserCustomClaims\n) {\n  const result = { success: true };\n  try {\n    await bucket.file(item).save(content);\n  } catch (error) {\n    result.success = false;\n  }\n  return result;\n}\n","import { Bucket } from '../../types/google-cloud-types';\nimport { StreamToPromise } from '../../utils/translation-helpers';\nimport { CoreTypes } from '../../types';\nimport { VError } from 'verror';\n\nexport async function GetFileContent(\n  bucket: Bucket,\n  item: string,\n  claims: CoreTypes.UserCustomClaims\n) {\n  try {\n    const result = await bucket.file(item).get();\n    const file = result[0];\n    const content = await StreamToPromise(file.createReadStream());\n    return content;\n  } catch (error) {\n    throw new VError(error);\n  }\n}\n","import { Storage, Bucket } from '../types/google-cloud-types';\nimport { commands } from './commands';\nimport { VError } from 'verror';\nimport { CoreTypes } from '../types';\nasync function CheckHasBodyProp(body: {}, bodyFieldName: string) {\n  const exists = body[bodyFieldName];\n  if (!exists) {\n    throw new Error(\n      `Request is missing property in req.body: '${bodyFieldName}'`\n    );\n  }\n}\n\nexport class NgxFileMangerApiFireBaseClass {\n  constructor(public storage: Storage) {}\n\n  private async getBucket(bucketname: string): Promise<Bucket> {\n    if (!bucketname) {\n      throw new Error(`Request is missing property in req.body: 'bucketname'`);\n    }\n    try {\n      const bucket = this.storage.bucket(bucketname);\n      const exists = (await bucket.exists()).shift();\n      if (!exists) {\n        throw new Error(\n          `bucket: \"${bucketname}\" doesn't exist, please create it first`\n        );\n      }\n      return bucket;\n    } catch (error) {\n      throw new Error('Error retrieving bucket: ' + error.message);\n    }\n  }\n\n  async HandleList(\n    body: CoreTypes.ReqBodyList,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyList> {\n    try {\n      await CheckHasBodyProp(body, 'path');\n      const bucket = await this.getBucket(body.bucketname);\n      const resFiles = await commands.GetList(\n        bucket,\n        body.path,\n        claims,\n        body.isAdmin\n      );\n      const response: CoreTypes.ResBodyList = {\n        result: resFiles\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleRename(\n    body: CoreTypes.ReqBodyRename,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyRename> {\n    try {\n      await CheckHasBodyProp(body, 'item');\n      await CheckHasBodyProp(body, 'newItemPath');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.RenameFile(\n        bucket,\n        body.item,\n        body.newItemPath,\n        claims\n      );\n      const response: CoreTypes.ResBodyRename = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleMove(\n    body: CoreTypes.ReqBodyMove,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyMove> {\n    try {\n      const bucket = await this.getBucket(body.bucketname);\n      await CheckHasBodyProp(body, 'items');\n      await CheckHasBodyProp(body, 'newPath');\n      const result = await commands.MoveFiles(\n        bucket,\n        body.items,\n        body.newPath,\n        claims\n      );\n      const response: CoreTypes.ResBodyMove = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleCopy(\n    body: CoreTypes.ReqBodyCopy,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyCopy> {\n    try {\n      await CheckHasBodyProp(body, 'newPath');\n      const bucket = await this.getBucket(body.bucketname);\n      let filesToCopy;\n      if (body.items) {\n        filesToCopy = body.items;\n      } else if (body.singleFileName) {\n        filesToCopy = [body.singleFileName];\n      } else {\n        throw new Error(\n          'Request does not contain either body.items or body.singleFileName'\n        );\n      }\n      const result = await commands.CopyFiles(\n        bucket,\n        filesToCopy,\n        body.newPath,\n        claims\n      );\n      const response: CoreTypes.ResBodyCopy = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleRemove(\n    body: CoreTypes.ReqBodyRemove,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyRemove> {\n    try {\n      await CheckHasBodyProp(body, 'items');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.RemoveFiles(bucket, body.items, claims);\n      const response: CoreTypes.ResBodyRemove = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleEdit(\n    body: CoreTypes.ReqBodyEdit,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyEdit> {\n    try {\n      await CheckHasBodyProp(body, 'item');\n      await CheckHasBodyProp(body, 'content');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.EditFile(\n        bucket,\n        body.item,\n        body.content,\n        claims\n      );\n      const response: CoreTypes.ResBodyEdit = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleGetContent(\n    body: CoreTypes.ReqBodyGetContent,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyGetContent> {\n    try {\n      await CheckHasBodyProp(body, 'item');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.GetFileContent(bucket, body.item, claims);\n      const response: CoreTypes.ResBodyGetContent = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleGetSingle(\n    body: CoreTypes.ReqBodyGetSingle,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyGetSingle> {\n    try {\n      await CheckHasBodyProp(body, 'item');\n      const bucket = await this.getBucket(body.bucketname);\n      const file = await commands.GetSingle(bucket, body.item, claims);\n      const response: CoreTypes.ResBodyGetSingle = {\n        result: {\n          success: true,\n          file: file,\n          url: file.downloadUrl\n        }\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleCreateFolder(\n    body: CoreTypes.ReqBodyCreateFolder,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyCreateFolder> {\n    try {\n      await CheckHasBodyProp(body, 'newPath');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.CreateFolder(\n        bucket,\n        body.newPath,\n        claims,\n        body.disableNoClobber,\n        body.isAdmin\n      );\n      const response: CoreTypes.ResBodyCreateFolder = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n\n  async HandleSetPermissions(\n    body: CoreTypes.ReqBodySetPermissions,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodySetPermissions> {\n    try {\n      await CheckHasBodyProp(body, 'items');\n      await CheckHasBodyProp(body, 'role');\n      await CheckHasBodyProp(body, 'entity');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.ChangePermissions(\n        bucket,\n        body.items,\n        body.role,\n        body.entity,\n        body.recursive,\n        claims\n      );\n      const response: CoreTypes.ResBodySetPermissions = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error.message);\n    }\n  }\n\n  async HandleSetPermissionsObject(\n    body: CoreTypes.ReqBodySetPermissionsObject,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodySetPermissions> {\n    try {\n      await CheckHasBodyProp(body, 'items');\n      await CheckHasBodyProp(body, 'permissionsObj');\n      const bucket = await this.getBucket(body.bucketname);\n      const result = await commands.ChangePermissionsObject(\n        bucket,\n        body.items,\n        body.permissionsObj,\n        body.recursive,\n        claims\n      );\n      const response: CoreTypes.ResBodySetPermissions = {\n        result: result\n      };\n      return response;\n    } catch (error) {\n      throw new VError(error.message);\n    }\n  }\n\n  async HandleSaveFile(\n    bucketname: string,\n    directoryPath: string,\n    originalname: string,\n    mimetype: string,\n    buffer: Buffer,\n    claims: CoreTypes.UserCustomClaims\n  ): Promise<CoreTypes.ResBodyUploadFile> {\n    try {\n      const bucket = await this.getBucket(bucketname);\n      await commands.UploadFile(\n        bucket,\n        directoryPath,\n        originalname,\n        mimetype,\n        buffer,\n        claims\n      );\n      const result = {\n        result: {\n          success: true\n        }\n      };\n      return result;\n    } catch (error) {\n      throw new VError(error);\n    }\n  }\n}\n","// Add middle ware to this route\nconst express = require('express');\nimport {\n  OptionRequestsAreOk,\n  PostRequestsOnly,\n  HasBodyProp,\n  HasQueryParam,\n  AddCors,\n  LogRequest\n} from './middleware-helpers';\nimport { Storage } from '../types/google-cloud-types';\nimport { NgxFileMangerApiFireBaseClass } from '../api/firebase-storage-api';\nimport { VError } from 'verror';\nimport { Request, Response, NextFunction } from 'express';\n\nlet fmApi: NgxFileMangerApiFireBaseClass;\nlet LOGGING = false;\n\nconst endpoint = express();\nendpoint.use(AddCors);\nendpoint.use(OptionRequestsAreOk);\nendpoint.use((req: Request, res: Response, next: NextFunction) => {\n  \n  req.body.path = `${req.body._c_id}/${req.body.path}`;\n  \n  if (LOGGING) {\n    LogRequest(req, res, next);\n  } else {\n    next();\n  }\n});\n\nendpoint.use('/hello', async (req, res) => {\n  console.log('HELLO');\n  res.status(200).send('HELLO\\n');\n});\n\nendpoint.use(PostRequestsOnly);\n\nimport { ParseUploadFile, UploadedFile } from './middleware-upload';\nimport { permsQueries } from '../permissions/permissions-queries';\nimport { CoreTypes } from '../types';\n\nendpoint.use(\n  '/upload',\n  OptionRequestsAreOk,\n  PostRequestsOnly,\n  HasQueryParam('bucketname'),\n  HasQueryParam('directoryPath'),\n  ParseUploadFile,\n  async (req, res, next) => {\n    const bucketname: string = req.query.bucketname;\n    const directoryPath: string = req.query.directoryPath;\n    try {\n      const files = req.files as UploadedFile[];\n      const userClaims = await permsQueries.RetrieveCustomClaims(req);\n      const results = await Promise.all(\n        files.map(file =>\n          trySaveFile(bucketname, directoryPath, file, userClaims)\n        )\n      );\n      const success = {\n        result: {\n          success: true\n        }\n      };\n      const finalResult = results.reduce((acc, cur) => {\n        if (cur.result.error) {\n          return cur;\n        }\n        return success;\n      }, success);\n      res.status(200).send(finalResult);\n    } catch (error) {\n      console.error(\n        'Error occurred while uploading: \\n',\n        VError.fullStack(error)\n      );\n      res\n        .status(400)\n        .send('Error occurred while uploading: \\n' + error.message);\n      return;\n    }\n  }\n);\n\nasync function trySaveFile(\n  bucketname: string,\n  directoryPath: string,\n  f: UploadedFile,\n  userClaims: CoreTypes.UserCustomClaims\n) {\n  return fmApi.HandleSaveFile(\n    bucketname,\n    directoryPath,\n    f.originalname,\n    f.mimetype,\n    f.buffer,\n    userClaims\n  );\n}\n\nendpoint.use(\n  '/',\n  HasBodyProp('action'),\n  HasBodyProp('bucketname'),\n  async (req, res) => {\n    const action: CoreTypes.FileManagerAction = req.body.action;\n    try {\n      const userClaims = await permsQueries.RetrieveCustomClaims(req);\n      let body;\n      switch (action) {\n        case 'list':\n          body = await fmApi.HandleList(req.body, userClaims);\n          break;\n        case 'rename':\n          body = await fmApi.HandleRename(req.body, userClaims);\n          break;\n        case 'move':\n          body = await fmApi.HandleMove(req.body, userClaims);\n          break;\n        case 'copy':\n          body = await fmApi.HandleCopy(req.body, userClaims);\n          break;\n        case 'remove':\n          body = await fmApi.HandleRemove(req.body, userClaims);\n          break;\n        case 'edit':\n          body = await fmApi.HandleEdit(req.body, userClaims);\n          break;\n        case 'getContent':\n          body = await fmApi.HandleGetContent(req.body, userClaims);\n          break;\n        case 'createFolder':\n          body = await fmApi.HandleCreateFolder(req.body, userClaims);\n          break;\n        case 'getSingle':\n          body = await fmApi.HandleGetSingle(req.body, userClaims);\n          break;\n        case 'changePermissions':\n          body = await fmApi.HandleSetPermissions(req.body, userClaims);\n          break;\n        case 'changePermissionsObject':\n          body = await fmApi.HandleSetPermissionsObject(req.body, userClaims);\n          break;\n        case 'compress':\n        case 'extract':\n        case 'downloadMultiple':\n        default:\n          throw new Error('action has not been implemented');\n      }\n      res.status(200).send(body);\n    } catch (error) {\n      console.error(\n        'Error while processing request: \\n',\n        VError.fullStack(error)\n      );\n      const returnedError = {\n        error: `Bad request to ngx-file-manager!`,\n        errorDetail: error.message,\n        requestBody: req.body\n      };\n      res.status(400).send(returnedError);\n    }\n  }\n);\nendpoint.use(notImplemented);\n\nasync function notImplemented(req, res) {\n  const bodyString = JSON.stringify(req.body);\n  res.status(501).send('That request has not been implemented: ' + bodyString);\n}\n\nexport interface FileManagerEndpointOptions {\n  logging?: boolean;\n  storage: Storage;\n}\n\n/*\nUse by attaching to a firebase function\nexports.FileManagerApi = StorageEndpoint;\n*/\nexport const FileManagerEndpointExpress = (\n  options: FileManagerEndpointOptions\n) => {\n  LOGGING = options.logging;\n  fmApi = new NgxFileMangerApiFireBaseClass(options.storage);\n  return endpoint;\n};\n","import { NextFunction } from 'express';\nimport * as formidable from 'formidable';\nimport * as fs from 'fs';\nimport { Files } from 'formidable';\n\nexport const ParseUploadFile = async (req, res, next: NextFunction) => {\n  try {\n    const form = new formidable.IncomingForm();\n    const files = await new Promise<formidable.File[]>((resolve, reject) => {\n      form.parse(req, function(err, fields, fieldFileMap: Files) {\n        const fileArray = Object.values(fieldFileMap) as formidable.File[];\n        resolve(fileArray);\n      });\n    });\n    const convertedFiles = await Promise.all(\n      files.map(f => convertToFileAndBuffer(f))\n    );\n    req.files = convertedFiles;\n    next();\n  } catch (error) {\n    console.error(error);\n    throw new Error(error);\n  }\n};\n\nasync function convertToFileAndBuffer(\n  f: formidable.File\n): Promise<UploadedFile> {\n  const fileBuffer = await new Promise<Buffer>((resolve, reject) =>\n    fs.readFile(f.path, function(err, buffer) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(buffer);\n      }\n    })\n  );\n  fs.unlinkSync(f.path);\n  return {\n    buffer: fileBuffer,\n    mimetype: f.type,\n    originalname: f.name,\n    hash: f.hash\n  };\n}\n\nexport interface UploadedFile {\n  buffer: Buffer;\n  hash: string;\n  mimetype: string;\n  originalname: string;\n}\n"],"mappings":"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"}